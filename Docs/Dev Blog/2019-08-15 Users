OK, so, there's a lot of stuff I don't understand at work here, so I'm going to do my best to try to explain how what we just built works but there will definitely be big gaps in the explanation.

The whole sign up flow was pretty straightforward. Only thing that feels worth mentioning is we created a separate "signup" mutation from the "createMember" mutation so we could have the server do a whole bunch of logic outside of just creating a member.

The way the data from the cookie gets to the website is the part that I understand the least, but I don't think there's much complexity that could mess things up in the future. Basically what we're doing is intercepting the request being sent to the server and then pulling the memberId out of the cookie and attaching it to that request. Then we created a new query called "me" which pulls the memberId out of the request and grabs the associated member for it. That query is called by a Member component, which then passes the grabbed member to its children as a payload. So to have access to the currently logged in member, all we have to do is wrap whatever component wants the data in a Member component, and then make the child of that Member component an arrow function which gives the payload as parameters and returns whatever it was we wanted to render with the data.

One very quirky thing worth noting here: that payload contains a bunch of stuff, including the data. So when we want to reference the data we do a double-destructing, like this: {({data: { me }}) => {console.log(me)}, where me will end up being an object with all the actual member information.